   1               		.file	"iambic.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.led_on,"ax",@progbits
  12               	led_on:
  13               	.LFB7:
  14               		.file 1 "iambic.c"
   1:iambic.c      **** /** \file
   2:iambic.c      ****  * Iambic USB keyer.
   3:iambic.c      ****  *
   4:iambic.c      ****  * Read an iambic keyer on port D and generate key press events
   5:iambic.c      ****  * based on the Morse code input.
   6:iambic.c      ****  *
   7:iambic.c      ****  * (c) 2012 Trammell Hudson <hudson@osresearch.net>
   8:iambic.c      ****  *
   9:iambic.c      ****  * Based on the
  10:iambic.c      ****  * Keyboard example with debug channel, for Teensy USB Development Board
  11:iambic.c      ****  * http://www.pjrc.com/teensy/usb_keyboard.html
  12:iambic.c      ****  * Copyright (c) 2008 PJRC.COM, LLC
  13:iambic.c      ****  * 
  14:iambic.c      ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
  15:iambic.c      ****  * of this software and associated documentation files (the "Software"), to deal
  16:iambic.c      ****  * in the Software without restriction, including without limitation the rights
  17:iambic.c      ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  18:iambic.c      ****  * copies of the Software, and to permit persons to whom the Software is
  19:iambic.c      ****  * furnished to do so, subject to the following conditions:
  20:iambic.c      ****  * 
  21:iambic.c      ****  * The above copyright notice and this permission notice shall be included in
  22:iambic.c      ****  * all copies or substantial portions of the Software.
  23:iambic.c      ****  * 
  24:iambic.c      ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  25:iambic.c      ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  26:iambic.c      ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  27:iambic.c      ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  28:iambic.c      ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  29:iambic.c      ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  30:iambic.c      ****  * THE SOFTWARE.
  31:iambic.c      ****  */
  32:iambic.c      **** 
  33:iambic.c      **** #include <avr/io.h>
  34:iambic.c      **** #include <avr/pgmspace.h>
  35:iambic.c      **** #include <avr/interrupt.h>
  36:iambic.c      **** #include <util/delay.h>
  37:iambic.c      **** #include "usb_keyboard_debug.h"
  38:iambic.c      **** #include "print.h"
  39:iambic.c      **** 
  40:iambic.c      **** #define CPU_PRESCALE(n)	(CLKPR = 0x80, CLKPR = (n))
  41:iambic.c      **** 
  42:iambic.c      **** #define LED_PIN (1 << 6)
  43:iambic.c      **** 
  44:iambic.c      **** static inline void
  45:iambic.c      **** led_on(void)
  46:iambic.c      **** {
  15               		.loc 1 46 1 view -0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  47:iambic.c      **** 	PORTD |= LED_PIN;
  21               		.loc 1 47 2 view .LVU1
  22               		.loc 1 47 8 is_stmt 0 view .LVU2
  23 0000 5E9A      		sbi 0xb,6
  48:iambic.c      **** 	DDRB |=  1 << 7; // OC0A enabled
  24               		.loc 1 48 2 is_stmt 1 view .LVU3
  25               		.loc 1 48 7 is_stmt 0 view .LVU4
  26 0002 279A      		sbi 0x4,7
  27               	/* epilogue start */
  49:iambic.c      **** }
  28               		.loc 1 49 1 view .LVU5
  29 0004 0895      		ret
  30               		.cfi_endproc
  31               	.LFE7:
  33               		.section	.text.led_off,"ax",@progbits
  35               	led_off:
  36               	.LFB8:
  50:iambic.c      **** 
  51:iambic.c      **** static inline void
  52:iambic.c      **** led_off(void)
  53:iambic.c      **** {
  37               		.loc 1 53 1 is_stmt 1 view -0
  38               		.cfi_startproc
  39               	/* prologue: function */
  40               	/* frame size = 0 */
  41               	/* stack size = 0 */
  42               	.L__stack_usage = 0
  54:iambic.c      **** 	PORTD &= ~LED_PIN;
  43               		.loc 1 54 2 view .LVU7
  44               		.loc 1 54 8 is_stmt 0 view .LVU8
  45 0000 5E98      		cbi 0xb,6
  55:iambic.c      **** 	DDRB &=  ~(1 << 7); // OC0A disabled
  46               		.loc 1 55 2 is_stmt 1 view .LVU9
  47               		.loc 1 55 7 is_stmt 0 view .LVU10
  48 0002 2798      		cbi 0x4,7
  49               	/* epilogue start */
  56:iambic.c      **** }
  50               		.loc 1 56 1 view .LVU11
  51 0004 0895      		ret
  52               		.cfi_endproc
  53               	.LFE8:
  55               		.section	.text.busy_wait,"ax",@progbits
  57               	busy_wait:
  58               	.LVL0:
  59               	.LFB12:
  57:iambic.c      **** 
  58:iambic.c      **** static inline void
  59:iambic.c      **** led_config(void)
  60:iambic.c      **** {
  61:iambic.c      **** 	DDRD |= LED_PIN;
  62:iambic.c      **** }
  63:iambic.c      **** 
  64:iambic.c      **** uint8_t number_keys[10]=
  65:iambic.c      **** 	{KEY_0,KEY_1,KEY_2,KEY_3,KEY_4,KEY_5,KEY_6,KEY_7,KEY_8,KEY_9};
  66:iambic.c      **** 
  67:iambic.c      **** uint16_t idle_count=0;
  68:iambic.c      **** 
  69:iambic.c      **** 
  70:iambic.c      **** static inline int
  71:iambic.c      **** is_dah(
  72:iambic.c      **** 	const uint8_t value
  73:iambic.c      **** )
  74:iambic.c      **** {
  75:iambic.c      **** 	return bit_is_clear(value, 4);
  76:iambic.c      **** }
  77:iambic.c      **** 
  78:iambic.c      **** 
  79:iambic.c      **** static inline int
  80:iambic.c      **** is_dit(
  81:iambic.c      **** 	const uint8_t value
  82:iambic.c      **** )
  83:iambic.c      **** {
  84:iambic.c      **** 	return bit_is_clear(value, 5);
  85:iambic.c      **** }
  86:iambic.c      **** 
  87:iambic.c      **** static uint16_t dah_count;
  88:iambic.c      **** static uint16_t dit_count;
  89:iambic.c      **** 
  90:iambic.c      **** 
  91:iambic.c      **** static void
  92:iambic.c      **** busy_wait(
  93:iambic.c      **** 	uint16_t delay_ticks
  94:iambic.c      **** )
  95:iambic.c      **** {
  60               		.loc 1 95 1 is_stmt 1 view -0
  61               		.cfi_startproc
  62               		.loc 1 95 1 is_stmt 0 view .LVU13
  63 0000 CF93      		push r28
  64               	.LCFI0:
  65               		.cfi_def_cfa_offset 3
  66               		.cfi_offset 28, -2
  67 0002 DF93      		push r29
  68               	.LCFI1:
  69               		.cfi_def_cfa_offset 4
  70               		.cfi_offset 29, -3
  71 0004 0F92      		push __tmp_reg__
  72               	.LCFI2:
  73               		.cfi_def_cfa_offset 5
  74 0006 CDB7      		in r28,__SP_L__
  75 0008 DEB7      		in r29,__SP_H__
  76               	.LCFI3:
  77               		.cfi_def_cfa_register 28
  78               	/* prologue: function */
  79               	/* frame size = 1 */
  80               	/* stack size = 3 */
  81               	.L__stack_usage = 3
  96:iambic.c      **** 	OCR1A = TCNT1 + delay_ticks;
  82               		.loc 1 96 2 is_stmt 1 view .LVU14
  83               		.loc 1 96 10 is_stmt 0 view .LVU15
  84 000a 2091 8400 		lds r18,132
  85 000e 3091 8500 		lds r19,132+1
  86               		.loc 1 96 16 view .LVU16
  87 0012 280F      		add r18,r24
  88 0014 391F      		adc r19,r25
  89               		.loc 1 96 8 view .LVU17
  90 0016 3093 8900 		sts 136+1,r19
  91 001a 2093 8800 		sts 136,r18
  97:iambic.c      **** 	TIFR1 |= (1 << OCF1A);
  92               		.loc 1 97 2 is_stmt 1 view .LVU18
  93               		.loc 1 97 8 is_stmt 0 view .LVU19
  94 001e B19A      		sbi 0x16,1
  98:iambic.c      **** 
  99:iambic.c      **** 	while (bit_is_clear(TIFR1, OCF1A))
  95               		.loc 1 99 2 is_stmt 1 view .LVU20
  96               	.LVL1:
  97               	.L6:
  98               		.loc 1 99 8 view .LVU21
  99 0020 B19B      		sbis 0x16,1
 100 0022 00C0      		rjmp .L7
 101               	/* epilogue start */
 100:iambic.c      **** 	{
 101:iambic.c      **** 		const uint8_t port = PINB;
 102:iambic.c      **** 		if (is_dah(port))
 103:iambic.c      **** 			dah_count++;
 104:iambic.c      **** 		if (is_dit(port))
 105:iambic.c      **** 			dit_count++;
 106:iambic.c      **** 	}
 107:iambic.c      **** }
 102               		.loc 1 107 1 is_stmt 0 view .LVU22
 103 0024 0F90      		pop __tmp_reg__
 104 0026 DF91      		pop r29
 105 0028 CF91      		pop r28
 106 002a 0895      		ret
 107               	.L7:
 108               	.LBB34:
 101:iambic.c      **** 		if (is_dah(port))
 109               		.loc 1 101 3 is_stmt 1 view .LVU23
 101:iambic.c      **** 		if (is_dah(port))
 110               		.loc 1 101 17 is_stmt 0 view .LVU24
 111 002c 23B1      		in r18,0x3
 112               	.LVL2:
 102:iambic.c      **** 			dah_count++;
 113               		.loc 1 102 3 is_stmt 1 view .LVU25
 114 002e 2983      		std Y+1,r18
 115               	.LVL3:
 116               	.LBB35:
 117               	.LBI35:
  71:iambic.c      **** 	const uint8_t value
 118               		.loc 1 71 1 view .LVU26
 119               	.LBB36:
  75:iambic.c      **** }
 120               		.loc 1 75 2 view .LVU27
  75:iambic.c      **** }
 121               		.loc 1 75 9 is_stmt 0 view .LVU28
 122 0030 8981      		ldd r24,Y+1
 123               	.LVL4:
  75:iambic.c      **** }
 124               		.loc 1 75 9 view .LVU29
 125               	.LBE36:
 126               	.LBE35:
 102:iambic.c      **** 			dah_count++;
 127               		.loc 1 102 6 view .LVU30
 128 0032 84FD      		sbrc r24,4
 129 0034 00C0      		rjmp .L5
 103:iambic.c      **** 		if (is_dit(port))
 130               		.loc 1 103 4 is_stmt 1 view .LVU31
 103:iambic.c      **** 		if (is_dit(port))
 131               		.loc 1 103 13 is_stmt 0 view .LVU32
 132 0036 8091 0000 		lds r24,dah_count
 133 003a 9091 0000 		lds r25,dah_count+1
 134 003e 0196      		adiw r24,1
 135 0040 9093 0000 		sts dah_count+1,r25
 136 0044 8093 0000 		sts dah_count,r24
 137               	.L5:
 104:iambic.c      **** 			dit_count++;
 138               		.loc 1 104 3 is_stmt 1 view .LVU33
 139 0048 2983      		std Y+1,r18
 140               	.LVL5:
 141               	.LBB37:
 142               	.LBI37:
  80:iambic.c      **** 	const uint8_t value
 143               		.loc 1 80 1 view .LVU34
 144               	.LBB38:
  84:iambic.c      **** }
 145               		.loc 1 84 2 view .LVU35
  84:iambic.c      **** }
 146               		.loc 1 84 9 is_stmt 0 view .LVU36
 147 004a 8981      		ldd r24,Y+1
 148               	.LVL6:
  84:iambic.c      **** }
 149               		.loc 1 84 9 view .LVU37
 150               	.LBE38:
 151               	.LBE37:
 104:iambic.c      **** 			dit_count++;
 152               		.loc 1 104 6 view .LVU38
 153 004c 85FD      		sbrc r24,5
 154 004e 00C0      		rjmp .L6
 105:iambic.c      **** 	}
 155               		.loc 1 105 4 is_stmt 1 view .LVU39
 105:iambic.c      **** 	}
 156               		.loc 1 105 13 is_stmt 0 view .LVU40
 157 0050 8091 0000 		lds r24,dit_count
 158 0054 9091 0000 		lds r25,dit_count+1
 159 0058 0196      		adiw r24,1
 160 005a 9093 0000 		sts dit_count+1,r25
 161 005e 8093 0000 		sts dit_count,r24
 162 0062 00C0      		rjmp .L6
 163               	.LBE34:
 164               		.cfi_endproc
 165               	.LFE12:
 167               		.section	.text.bad_input,"ax",@progbits
 169               	bad_input:
 170               	.LFB14:
 108:iambic.c      **** 
 109:iambic.c      **** 
 110:iambic.c      **** static void
 111:iambic.c      **** wait(
 112:iambic.c      **** 	uint16_t on_ticks,
 113:iambic.c      **** 	uint16_t off_ticks
 114:iambic.c      **** )
 115:iambic.c      **** {
 116:iambic.c      **** 	dit_count = dah_count = 0;
 117:iambic.c      **** 
 118:iambic.c      **** 	led_on();
 119:iambic.c      **** 	busy_wait(on_ticks);
 120:iambic.c      **** 
 121:iambic.c      **** 	led_off();
 122:iambic.c      **** 	busy_wait(off_ticks);
 123:iambic.c      **** }
 124:iambic.c      **** 
 125:iambic.c      **** 
 126:iambic.c      **** static void
 127:iambic.c      **** bad_input(void)
 128:iambic.c      **** {
 171               		.loc 1 128 1 is_stmt 1 view -0
 172               		.cfi_startproc
 173 0000 CF93      		push r28
 174               	.LCFI4:
 175               		.cfi_def_cfa_offset 3
 176               		.cfi_offset 28, -2
 177               	/* prologue: function */
 178               	/* frame size = 0 */
 179               	/* stack size = 1 */
 180               	.L__stack_usage = 1
 129:iambic.c      **** 	uint8_t tccr0b = TCCR0B;
 181               		.loc 1 129 2 view .LVU42
 182               		.loc 1 129 10 is_stmt 0 view .LVU43
 183 0002 C5B5      		in r28,0x25
 184               	.LVL7:
 130:iambic.c      **** 	TCCR0B = 0x04; // Clk/256
 185               		.loc 1 130 2 is_stmt 1 view .LVU44
 186               		.loc 1 130 9 is_stmt 0 view .LVU45
 187 0004 84E0      		ldi r24,lo8(4)
 188 0006 85BD      		out 0x25,r24
 131:iambic.c      **** 	led_on();
 189               		.loc 1 131 2 is_stmt 1 view .LVU46
 190 0008 0E94 0000 		call led_on
 191               	.LVL8:
 132:iambic.c      **** 	print("!!!\n");
 192               		.loc 1 132 2 view .LVU47
 193               	.LBB39:
 194               		.loc 1 132 2 view .LVU48
 195               		.loc 1 132 2 view .LVU49
 196               	.LBE39:
 197 000c 80E0      		ldi r24,lo8(__c.1835)
 198 000e 90E0      		ldi r25,hi8(__c.1835)
 199 0010 0E94 0000 		call print_P
 200               	.LVL9:
 133:iambic.c      **** 	_delay_ms(40);
 201               		.loc 1 133 2 view .LVU50
 202               	.LBB40:
 203               	.LBI40:
 204               		.file 2 "/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** _delay_ms(double __ms)
 205               		.loc 2 166 1 view .LVU51
 206               	.LBB41:
 167:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	double __tmp ;
 207               		.loc 2 168 2 view .LVU52
 169:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 208               		.loc 2 172 2 view .LVU53
 173:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 209               		.loc 2 173 2 view .LVU54
 174:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 210               		.loc 2 174 2 view .LVU55
 175:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 211               		.loc 2 184 3 view .LVU56
 185:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 212               		.loc 2 187 2 view .LVU57
 213 0014 2FEF      		ldi r18,lo8(127999)
 214 0016 83EF      		ldi r24,hi8(127999)
 215 0018 91E0      		ldi r25,hlo8(127999)
 216 001a 2150      	1:	subi r18,1
 217 001c 8040      		sbci r24,0
 218 001e 9040      		sbci r25,0
 219 0020 01F4      		brne 1b
 220 0022 00C0      		rjmp .
 221 0024 0000      		nop
 222               	.LVL10:
 223               		.loc 2 187 2 is_stmt 0 view .LVU58
 224               	.LBE41:
 225               	.LBE40:
 134:iambic.c      **** 	led_off();
 226               		.loc 1 134 2 is_stmt 1 view .LVU59
 227 0026 0E94 0000 		call led_off
 228               	.LVL11:
 135:iambic.c      **** 
 136:iambic.c      **** 	// Restore the old timer
 137:iambic.c      **** 	TCCR0B = tccr0b;
 229               		.loc 1 137 2 view .LVU60
 230               		.loc 1 137 9 is_stmt 0 view .LVU61
 231 002a C5BD      		out 0x25,r28
 232               	/* epilogue start */
 138:iambic.c      **** }
 233               		.loc 1 138 1 view .LVU62
 234 002c CF91      		pop r28
 235               	.LVL12:
 236               		.loc 1 138 1 view .LVU63
 237 002e 0895      		ret
 238               		.cfi_endproc
 239               	.LFE14:
 241               		.section	.text.startup.main,"ax",@progbits
 242               	.global	main
 244               	main:
 245               	.LFB15:
 139:iambic.c      **** 
 140:iambic.c      **** 
 141:iambic.c      **** int main(void)
 142:iambic.c      **** {
 246               		.loc 1 142 1 is_stmt 1 view -0
 247               		.cfi_startproc
 248 0000 0F92      		push __tmp_reg__
 249               	.LCFI5:
 250               		.cfi_def_cfa_offset 3
 251 0002 CDB7      		in r28,__SP_L__
 252 0004 DEB7      		in r29,__SP_H__
 253               	.LCFI6:
 254               		.cfi_def_cfa_register 28
 255               	/* prologue: function */
 256               	/* frame size = 1 */
 257               	/* stack size = 1 */
 258               	.L__stack_usage = 1
 143:iambic.c      **** 	uint8_t b, d, mask, i, reset_idle;
 259               		.loc 1 143 2 view .LVU65
 144:iambic.c      **** 	uint8_t b_prev=0xFF, d_prev=0xFF;
 260               		.loc 1 144 2 view .LVU66
 261               	.LVL13:
 145:iambic.c      **** 
 146:iambic.c      **** 	// set for 16 MHz clock
 147:iambic.c      **** 	CPU_PRESCALE(0);
 262               		.loc 1 147 2 view .LVU67
 263 0006 80E8      		ldi r24,lo8(-128)
 264 0008 8093 6100 		sts 97,r24
 265 000c 1092 6100 		sts 97,__zero_reg__
 148:iambic.c      **** 	led_config();
 266               		.loc 1 148 2 view .LVU68
 267               	.LBB64:
 268               	.LBI64:
  59:iambic.c      **** {
 269               		.loc 1 59 1 view .LVU69
 270               	.LBB65:
  61:iambic.c      **** }
 271               		.loc 1 61 2 view .LVU70
  61:iambic.c      **** }
 272               		.loc 1 61 7 is_stmt 0 view .LVU71
 273 0010 569A      		sbi 0xa,6
 274               	.LBE65:
 275               	.LBE64:
 149:iambic.c      **** 
 150:iambic.c      **** 	// Configure all port B and port D pins as inputs with pullup resistors.
 151:iambic.c      **** 	// See the "Using I/O Pins" page for details.
 152:iambic.c      **** 	// http://www.pjrc.com/teensy/pins.html
 153:iambic.c      **** 	DDRD = 0x00;
 276               		.loc 1 153 2 is_stmt 1 view .LVU72
 277               		.loc 1 153 7 is_stmt 0 view .LVU73
 278 0012 1AB8      		out 0xa,__zero_reg__
 154:iambic.c      **** 	DDRB = 0x00;
 279               		.loc 1 154 2 is_stmt 1 view .LVU74
 280               		.loc 1 154 7 is_stmt 0 view .LVU75
 281 0014 14B8      		out 0x4,__zero_reg__
 155:iambic.c      **** 	PORTB = 0xFF;
 282               		.loc 1 155 2 is_stmt 1 view .LVU76
 283               		.loc 1 155 8 is_stmt 0 view .LVU77
 284 0016 8FEF      		ldi r24,lo8(-1)
 285 0018 85B9      		out 0x5,r24
 156:iambic.c      **** 	PORTD = 0xFF;
 286               		.loc 1 156 2 is_stmt 1 view .LVU78
 287               		.loc 1 156 8 is_stmt 0 view .LVU79
 288 001a 8BB9      		out 0xb,r24
 157:iambic.c      **** 
 158:iambic.c      **** 	// Initialize the USB, and then wait for the host to set configuration.
 159:iambic.c      **** 	// If the Teensy is powered without a PC connected to the USB port,
 160:iambic.c      **** 	// this will wait forever.
 161:iambic.c      **** 	usb_init();
 289               		.loc 1 161 2 is_stmt 1 view .LVU80
 290 001c 0E94 0000 		call usb_init
 291               	.LVL14:
 162:iambic.c      **** 	while (!usb_configured())
 292               		.loc 1 162 2 view .LVU81
 293               	.L11:
 163:iambic.c      **** 	{
 164:iambic.c      **** 		/* busy wait */
 165:iambic.c      **** 	}
 294               		.loc 1 165 2 discriminator 1 view .LVU82
 162:iambic.c      **** 	while (!usb_configured())
 295               		.loc 1 162 8 discriminator 1 view .LVU83
 162:iambic.c      **** 	while (!usb_configured())
 296               		.loc 1 162 10 is_stmt 0 discriminator 1 view .LVU84
 297 0020 0E94 0000 		call usb_configured
 298               	.LVL15:
 162:iambic.c      **** 	while (!usb_configured())
 299               		.loc 1 162 8 discriminator 1 view .LVU85
 300 0024 8823      		tst r24
 301 0026 01F0      		breq .L11
 166:iambic.c      **** 
 167:iambic.c      **** 	// Wait an extra second for the PC's operating system to load drivers
 168:iambic.c      **** 	// and do whatever it does to actually be ready for input
 169:iambic.c      **** 	_delay_ms(1000);
 302               		.loc 1 169 2 is_stmt 1 view .LVU86
 303               	.LVL16:
 304               	.LBB66:
 305               	.LBI66:
 166:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** {
 306               		.loc 2 166 1 view .LVU87
 307               	.LBB67:
 168:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 308               		.loc 2 168 2 view .LVU88
 172:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 309               		.loc 2 172 2 view .LVU89
 173:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 310               		.loc 2 173 2 view .LVU90
 174:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 311               		.loc 2 174 2 view .LVU91
 184:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	#endif
 312               		.loc 2 184 3 view .LVU92
 313               		.loc 2 187 2 view .LVU93
 314 0028 2FEF      		ldi r18,lo8(3199999)
 315 002a 83ED      		ldi r24,hi8(3199999)
 316 002c 90E3      		ldi r25,hlo8(3199999)
 317 002e 2150      	1:	subi r18,1
 318 0030 8040      		sbci r24,0
 319 0032 9040      		sbci r25,0
 320 0034 01F4      		brne 1b
 321 0036 00C0      		rjmp .
 322 0038 0000      		nop
 323               	.LVL17:
 324               		.loc 2 187 2 is_stmt 0 view .LVU94
 325               	.LBE67:
 326               	.LBE66:
 327               		.file 3 "morse.h"
   1:morse.h       **** static const uint8_t morse[256] PROGMEM = {
 328               		.loc 3 1 1 is_stmt 1 view .LVU95
 170:iambic.c      **** 
 171:iambic.c      **** /*
 172:iambic.c      **** * http://en.wikipedia.org/wiki/Morse_code#Representation.2C_timing_and_speeds
 173:iambic.c      **** *
 174:iambic.c      **** * International Morse code is composed of five elements:
 175:iambic.c      **** *
 176:iambic.c      **** * short mark, dot or 'dit' (·) — 'dot duration' is one unit long
 177:iambic.c      **** * longer mark, dash or 'dah' (–) — three units long
 178:iambic.c      **** * inter-element gap between the dots and dashes within a character
 179:iambic.c      **** *   - one dot duration or one unit long
 180:iambic.c      **** * short gap (between letters) — three units long
 181:iambic.c      **** * medium gap (between words) — seven units long[19]
 182:iambic.c      **** *
 183:iambic.c      **** * Based upon a 50 dot duration standard word such as PARIS, the time
 184:iambic.c      **** * for one dot duration or one unit can be computed by the formula:
 185:iambic.c      **** * T = 1200 / W
 186:iambic.c      **** * or
 187:iambic.c      **** * T = 6000 / C
 188:iambic.c      **** * Where: T is the unit time, or dot duration, in milliseconds,
 189:iambic.c      **** * W is the speed in wpm, and C is the speed in cpm.
 190:iambic.c      **** */
 191:iambic.c      **** 
 192:iambic.c      **** #include "morse.h"
 193:iambic.c      **** 
 194:iambic.c      **** 	// 
 195:iambic.c      **** 	// 256*1024 clock cycles, or approx 61 Hz when using 16 MHz clock
 196:iambic.c      **** 	// This demonstrates how to use interrupts to implement a simple
 197:iambic.c      **** 	// inactivity timeout.
 198:iambic.c      **** 	TCCR0A = 0x00;
 329               		.loc 1 198 2 view .LVU96
 330               		.loc 1 198 9 is_stmt 0 view .LVU97
 331 003a 14BC      		out 0x24,__zero_reg__
 199:iambic.c      **** 	TCCR0B = 0x05;
 332               		.loc 1 199 2 is_stmt 1 view .LVU98
 333               		.loc 1 199 9 is_stmt 0 view .LVU99
 334 003c 85E0      		ldi r24,lo8(5)
 335 003e 85BD      		out 0x25,r24
 200:iambic.c      **** 	//TIMSK0 = (1<<TOIE0);
 201:iambic.c      **** 
 202:iambic.c      **** 	// TCNT1 runs at CLK/1024, which is 0.064 ms per tick
 203:iambic.c      **** 	// This is pretty close to 16 ticks/ms.  The output compare
 204:iambic.c      **** 	// sets OCF flag on match
 205:iambic.c      **** 	TCCR1B = 5; // clk/1024
 336               		.loc 1 205 2 is_stmt 1 view .LVU100
 337               		.loc 1 205 9 is_stmt 0 view .LVU101
 338 0040 8093 8100 		sts 129,r24
 206:iambic.c      ****         // const uint8_t cpm = 15;
 207:iambic.c      **** 	const uint8_t cpm = 25;
 339               		.loc 1 207 2 is_stmt 1 view .LVU102
 340               	.LVL18:
 208:iambic.c      **** 	const uint16_t dit_time = (1600 / cpm) * 16;
 341               		.loc 1 208 2 view .LVU103
 209:iambic.c      **** 	const uint16_t button_threshold = 16384; // dit_time * 1024 * 4;
 342               		.loc 1 209 2 view .LVU104
 210:iambic.c      **** 
 211:iambic.c      **** 	// TCNT0 is configured for a 500 Hz tone on OC0A
 212:iambic.c      **** 	// At CLK/64, this is turns on and off each time
 213:iambic.c      **** 	// a full counter is made, which creates a 488 Hz
 214:iambic.c      **** 	// square wave.
 215:iambic.c      **** 	TCCR0A = (1 << COM0A0) | (1 << COM0A1) | 0x03;
 343               		.loc 1 215 2 view .LVU105
 344               		.loc 1 215 9 is_stmt 0 view .LVU106
 345 0044 83EC      		ldi r24,lo8(-61)
 346 0046 84BD      		out 0x24,r24
 216:iambic.c      **** 	TCCR0B = 0x03; // CLK/64
 347               		.loc 1 216 2 is_stmt 1 view .LVU107
 348               		.loc 1 216 9 is_stmt 0 view .LVU108
 349 0048 83E0      		ldi r24,lo8(3)
 350 004a 85BD      		out 0x25,r24
 217:iambic.c      **** 	OCR0A = 0x80; // low volume
 351               		.loc 1 217 2 is_stmt 1 view .LVU109
 352               		.loc 1 217 8 is_stmt 0 view .LVU110
 353 004c 80E8      		ldi r24,lo8(-128)
 354 004e 87BD      		out 0x27,r24
 218:iambic.c      **** 
 219:iambic.c      **** 	// Set mode to fast, inverted PWM
 220:iambic.c      **** 	
 221:iambic.c      **** 	led_off();
 355               		.loc 1 221 2 is_stmt 1 view .LVU111
 356 0050 0E94 0000 		call led_off
 357               	.LVL19:
 222:iambic.c      **** 
 223:iambic.c      **** 	uint8_t value = 1;
 358               		.loc 1 223 2 view .LVU112
 224:iambic.c      **** 	uint8_t bits = 0;
 359               		.loc 1 224 2 view .LVU113
 225:iambic.c      **** 	uint8_t last_bit = 0;
 360               		.loc 1 225 2 view .LVU114
 226:iambic.c      **** 
 227:iambic.c      **** 	while (1)
 361               		.loc 1 227 2 view .LVU115
 362               	.LBB68:
 228:iambic.c      **** 	{
 229:iambic.c      **** 		// Read PINB, which has both input pins
 230:iambic.c      **** 		// since there is a pull-up, the pins will be pulled
 231:iambic.c      **** 		// to ground when the switch is hit.
 232:iambic.c      **** 
 233:iambic.c      **** 		if (bits > 7)
 363               		.loc 1 233 3 view .LVU116
 364               	.L23:
 365               		.loc 1 233 3 is_stmt 0 view .LVU117
 366               	.LBE68:
 223:iambic.c      **** 	uint8_t bits = 0;
 367               		.loc 1 223 10 view .LVU118
 368 0054 00E0      		ldi r16,0
 369 0056 11E0      		ldi r17,lo8(1)
 370               	.L14:
 371               	.LBB86:
 234:iambic.c      **** 		{
 235:iambic.c      **** 			// Too many symbols.  Ignore it
 236:iambic.c      **** 			bad_input();
 237:iambic.c      **** 			goto reset;
 238:iambic.c      **** 		} else
 239:iambic.c      **** 		if (is_dit(PINB))
 372               		.loc 1 239 3 is_stmt 1 view .LVU119
 373               		.loc 1 239 7 is_stmt 0 view .LVU120
 374 0058 83B1      		in r24,0x3
 375 005a 8983      		std Y+1,r24
 376               	.LVL20:
 377               	.LBB69:
 378               	.LBI69:
  80:iambic.c      **** 	const uint8_t value
 379               		.loc 1 80 1 is_stmt 1 view .LVU121
 380               	.LBB70:
  84:iambic.c      **** }
 381               		.loc 1 84 2 view .LVU122
  84:iambic.c      **** }
 382               		.loc 1 84 9 is_stmt 0 view .LVU123
 383 005c 8981      		ldd r24,Y+1
 384               	.LVL21:
  84:iambic.c      **** }
 385               		.loc 1 84 9 view .LVU124
 386               	.LBE70:
 387               	.LBE69:
 388               		.loc 1 239 6 view .LVU125
 389 005e 85FD      		sbrc r24,5
 390 0060 00C0      		rjmp .L15
 391               	.L16:
 392               	.LVL22:
 240:iambic.c      **** 		{
 241:iambic.c      **** 			// The dit key is held down and
 242:iambic.c      **** 			// If the last bit sent was also a dit and the
 243:iambic.c      **** 			// dah switch is enabled, send a dah instead.
 244:iambic.c      **** start_dit_bit:
 245:iambic.c      **** 			bits++;
 393               		.loc 1 245 4 is_stmt 1 view .LVU126
 394               		.loc 1 245 8 is_stmt 0 view .LVU127
 395 0062 0F5F      		subi r16,lo8(-(1))
 396               	.LVL23:
 246:iambic.c      **** 			value <<= 1;
 397               		.loc 1 246 4 is_stmt 1 view .LVU128
 398               		.loc 1 246 10 is_stmt 0 view .LVU129
 399 0064 110F      		lsl r17
 400               	.LVL24:
 247:iambic.c      **** 			print(".");
 401               		.loc 1 247 4 is_stmt 1 view .LVU130
 402               	.LBB71:
 403               		.loc 1 247 4 view .LVU131
 404               		.loc 1 247 4 view .LVU132
 405               	.LBE71:
 406 0066 80E0      		ldi r24,lo8(__c.1859)
 407 0068 90E0      		ldi r25,hi8(__c.1859)
 408 006a 0E94 0000 		call print_P
 409               	.LVL25:
 248:iambic.c      **** 
 249:iambic.c      **** 			wait(dit_time, dit_time);
 410               		.loc 1 249 4 view .LVU133
 411               	.LBB72:
 412               	.LBI72:
 111:iambic.c      **** 	uint16_t on_ticks,
 413               		.loc 1 111 1 view .LVU134
 414               	.LBB73:
 116:iambic.c      **** 
 415               		.loc 1 116 2 view .LVU135
 116:iambic.c      **** 
 416               		.loc 1 116 24 is_stmt 0 view .LVU136
 417 006e 1092 0000 		sts dah_count+1,__zero_reg__
 418 0072 1092 0000 		sts dah_count,__zero_reg__
 116:iambic.c      **** 
 419               		.loc 1 116 12 view .LVU137
 420 0076 1092 0000 		sts dit_count+1,__zero_reg__
 421 007a 1092 0000 		sts dit_count,__zero_reg__
 118:iambic.c      **** 	busy_wait(on_ticks);
 422               		.loc 1 118 2 is_stmt 1 view .LVU138
 423 007e 0E94 0000 		call led_on
 424               	.LVL26:
 119:iambic.c      **** 
 425               		.loc 1 119 2 view .LVU139
 426 0082 80E0      		ldi r24,0
 427 0084 94E0      		ldi r25,lo8(4)
 428 0086 0E94 0000 		call busy_wait
 429               	.LVL27:
 121:iambic.c      **** 	busy_wait(off_ticks);
 430               		.loc 1 121 2 view .LVU140
 431 008a 0E94 0000 		call led_off
 432               	.LVL28:
 122:iambic.c      **** }
 433               		.loc 1 122 2 view .LVU141
 434 008e 80E0      		ldi r24,0
 435 0090 94E0      		ldi r25,lo8(4)
 436 0092 0E94 0000 		call busy_wait
 437               	.LVL29:
 122:iambic.c      **** }
 438               		.loc 1 122 2 is_stmt 0 view .LVU142
 439               	.LBE73:
 440               	.LBE72:
 250:iambic.c      **** 			if (dah_count > button_threshold)
 441               		.loc 1 250 4 is_stmt 1 view .LVU143
 442               		.loc 1 250 7 is_stmt 0 view .LVU144
 443 0096 8091 0000 		lds r24,dah_count
 444 009a 9091 0000 		lds r25,dah_count+1
 445 009e 8130      		cpi r24,1
 446 00a0 9044      		sbci r25,64
 447 00a2 00F4      		brsh .L17
 448               	.L18:
 449               		.loc 1 250 7 view .LVU145
 450               	.LBE86:
 227:iambic.c      **** 	{
 451               		.loc 1 227 2 is_stmt 1 view .LVU146
 452               	.LBB87:
 233:iambic.c      **** 		{
 453               		.loc 1 233 3 view .LVU147
 233:iambic.c      **** 		{
 454               		.loc 1 233 6 is_stmt 0 view .LVU148
 455 00a4 0830      		cpi r16,lo8(8)
 456 00a6 00F0      		brlo .L14
 457               	.LVL30:
 458               	.L35:
 236:iambic.c      **** 			goto reset;
 459               		.loc 1 236 4 is_stmt 1 view .LVU149
 460 00a8 0E94 0000 		call bad_input
 461               	.LVL31:
 237:iambic.c      **** 		} else
 462               		.loc 1 237 4 view .LVU150
 463 00ac 00C0      		rjmp .L23
 464               	.L15:
 251:iambic.c      **** 				goto start_dah_bit;
 252:iambic.c      **** 
 253:iambic.c      **** 			continue;
 254:iambic.c      **** 		} else
 255:iambic.c      **** 		if (is_dah(PINB))
 465               		.loc 1 255 3 view .LVU151
 466               		.loc 1 255 7 is_stmt 0 view .LVU152
 467 00ae 83B1      		in r24,0x3
 468 00b0 8983      		std Y+1,r24
 469               	.LVL32:
 470               	.LBB74:
 471               	.LBI74:
  71:iambic.c      **** 	const uint8_t value
 472               		.loc 1 71 1 is_stmt 1 view .LVU153
 473               	.LBB75:
  75:iambic.c      **** }
 474               		.loc 1 75 2 view .LVU154
  75:iambic.c      **** }
 475               		.loc 1 75 9 is_stmt 0 view .LVU155
 476 00b2 8981      		ldd r24,Y+1
 477               	.LVL33:
  75:iambic.c      **** }
 478               		.loc 1 75 9 view .LVU156
 479               	.LBE75:
 480               	.LBE74:
 481               		.loc 1 255 6 view .LVU157
 482 00b4 84FD      		sbrc r24,4
 483 00b6 00C0      		rjmp .L19
 484               	.L17:
 485               	.LVL34:
 256:iambic.c      **** 		{
 257:iambic.c      **** start_dah_bit:
 258:iambic.c      **** 			bits++;
 486               		.loc 1 258 4 is_stmt 1 view .LVU158
 487               		.loc 1 258 8 is_stmt 0 view .LVU159
 488 00b8 0F5F      		subi r16,lo8(-(1))
 489               	.LVL35:
 259:iambic.c      **** 			value = (value << 1) | 1;
 490               		.loc 1 259 4 is_stmt 1 view .LVU160
 491               		.loc 1 259 19 is_stmt 0 view .LVU161
 492 00ba 110F      		lsl r17
 493               	.LVL36:
 494               		.loc 1 259 25 view .LVU162
 495 00bc 1160      		ori r17,lo8(1)
 496               	.LVL37:
 260:iambic.c      **** 			print("-");
 497               		.loc 1 260 4 is_stmt 1 view .LVU163
 498               	.LBB76:
 499               		.loc 1 260 4 view .LVU164
 500               		.loc 1 260 4 view .LVU165
 501               	.LBE76:
 502 00be 80E0      		ldi r24,lo8(__c.1863)
 503 00c0 90E0      		ldi r25,hi8(__c.1863)
 504 00c2 0E94 0000 		call print_P
 505               	.LVL38:
 261:iambic.c      **** 
 262:iambic.c      **** 			wait(3*dit_time, dit_time);
 506               		.loc 1 262 4 view .LVU166
 507               	.LBB77:
 508               	.LBI77:
 111:iambic.c      **** 	uint16_t on_ticks,
 509               		.loc 1 111 1 view .LVU167
 510               	.LBB78:
 116:iambic.c      **** 
 511               		.loc 1 116 2 view .LVU168
 116:iambic.c      **** 
 512               		.loc 1 116 24 is_stmt 0 view .LVU169
 513 00c6 1092 0000 		sts dah_count+1,__zero_reg__
 514 00ca 1092 0000 		sts dah_count,__zero_reg__
 116:iambic.c      **** 
 515               		.loc 1 116 12 view .LVU170
 516 00ce 1092 0000 		sts dit_count+1,__zero_reg__
 517 00d2 1092 0000 		sts dit_count,__zero_reg__
 118:iambic.c      **** 	busy_wait(on_ticks);
 518               		.loc 1 118 2 is_stmt 1 view .LVU171
 519 00d6 0E94 0000 		call led_on
 520               	.LVL39:
 119:iambic.c      **** 
 521               		.loc 1 119 2 view .LVU172
 522 00da 80E0      		ldi r24,0
 523 00dc 9CE0      		ldi r25,lo8(12)
 524 00de 0E94 0000 		call busy_wait
 525               	.LVL40:
 121:iambic.c      **** 	busy_wait(off_ticks);
 526               		.loc 1 121 2 view .LVU173
 527 00e2 0E94 0000 		call led_off
 528               	.LVL41:
 122:iambic.c      **** }
 529               		.loc 1 122 2 view .LVU174
 530 00e6 80E0      		ldi r24,0
 531 00e8 94E0      		ldi r25,lo8(4)
 532 00ea 0E94 0000 		call busy_wait
 533               	.LVL42:
 122:iambic.c      **** }
 534               		.loc 1 122 2 is_stmt 0 view .LVU175
 535               	.LBE78:
 536               	.LBE77:
 263:iambic.c      **** 			if (dit_count > button_threshold)
 537               		.loc 1 263 4 is_stmt 1 view .LVU176
 538               		.loc 1 263 7 is_stmt 0 view .LVU177
 539 00ee 8091 0000 		lds r24,dit_count
 540 00f2 9091 0000 		lds r25,dit_count+1
 541 00f6 8130      		cpi r24,1
 542 00f8 9044      		sbci r25,64
 543 00fa 00F0      		brlo .+2
 544 00fc 00C0      		rjmp .L16
 545 00fe 00C0      		rjmp .L18
 546               	.LVL43:
 547               	.L19:
 264:iambic.c      **** 				goto start_dit_bit;
 265:iambic.c      **** 
 266:iambic.c      **** 			continue;
 267:iambic.c      **** 		} else
 268:iambic.c      **** 		if (bits == 0)
 548               		.loc 1 268 3 is_stmt 1 view .LVU178
 549               		.loc 1 268 6 is_stmt 0 view .LVU179
 550 0100 0023      		tst r16
 551 0102 01F4      		brne .+2
 552 0104 00C0      		rjmp .L14
 269:iambic.c      **** 		{
 270:iambic.c      **** 
 271:iambic.c      **** #if 0
 272:iambic.c      **** 			if (last_send_time && now() > last_send_time)
 273:iambic.c      **** 				usb_keyboard_press(KEY_SPACE, 0);
 274:iambic.c      **** 			last_send_time = 0;
 275:iambic.c      **** #endif
 276:iambic.c      **** 			continue;
 277:iambic.c      **** 		}
 278:iambic.c      **** 
 279:iambic.c      **** 		// Neither key is held down and the single space time
 280:iambic.c      **** 		// has elapsed (since wait_delay is blocking).
 281:iambic.c      **** 
 282:iambic.c      **** 		// Delay one more cycle to be sure, abort the delay
 283:iambic.c      **** 		// as soon as a button is pressed
 284:iambic.c      **** 		OCR1A = TCNT1 + dit_time * 2;
 553               		.loc 1 284 3 is_stmt 1 view .LVU180
 554               		.loc 1 284 11 is_stmt 0 view .LVU181
 555 0106 8091 8400 		lds r24,132
 556 010a 9091 8500 		lds r25,132+1
 557               		.loc 1 284 17 view .LVU182
 558 010e 985F      		subi r25,-8
 559               		.loc 1 284 9 view .LVU183
 560 0110 9093 8900 		sts 136+1,r25
 561 0114 8093 8800 		sts 136,r24
 285:iambic.c      **** 		TIFR1 |= (1 << OCF1A);
 562               		.loc 1 285 3 is_stmt 1 view .LVU184
 563               		.loc 1 285 9 is_stmt 0 view .LVU185
 564 0118 B19A      		sbi 0x16,1
 286:iambic.c      **** 
 287:iambic.c      **** 		while (bit_is_clear(TIFR1, OCF1A))
 565               		.loc 1 287 3 is_stmt 1 view .LVU186
 566               	.L20:
 567               		.loc 1 287 9 view .LVU187
 568 011a B19B      		sbis 0x16,1
 569 011c 00C0      		rjmp .L21
 288:iambic.c      **** 		{
 289:iambic.c      **** 			const uint8_t port = PINB;
 290:iambic.c      **** 			if (is_dah(port))
 291:iambic.c      **** 				goto start_dah_bit;
 292:iambic.c      **** 			if (is_dit(port))
 293:iambic.c      **** 				goto start_dit_bit;
 294:iambic.c      **** 		}
 295:iambic.c      **** 
 296:iambic.c      **** 		// Timeout has passed; check to see if the
 297:iambic.c      **** 		// value exist in the map
 298:iambic.c      **** 		uint8_t c = pgm_read_byte(&morse[value]);
 570               		.loc 1 298 3 view .LVU188
 571               	.LBB79:
 572               		.loc 1 298 15 view .LVU189
 573               	.LVL44:
 574               		.loc 1 298 15 view .LVU190
 575               		.loc 1 298 15 view .LVU191
 576 011e E12F      		mov r30,r17
 577 0120 F0E0      		ldi r31,0
 578 0122 E050      		subi r30,lo8(-(morse.1850))
 579 0124 F040      		sbci r31,hi8(-(morse.1850))
 580               	/* #APP */
 581               	 ;  298 "iambic.c" 1
 582 0126 0491      		lpm r16, Z
 583               		
 584               	 ;  0 "" 2
 585               	.LVL45:
 586               		.loc 1 298 15 view .LVU192
 587               		.loc 1 298 15 is_stmt 0 view .LVU193
 588               	/* #NOAPP */
 589               	.LBE79:
 299:iambic.c      **** 
 300:iambic.c      **** 		//last_send_time = now();
 301:iambic.c      **** 		print(" = ");
 590               		.loc 1 301 3 is_stmt 1 view .LVU194
 591               	.LBB80:
 592               		.loc 1 301 3 view .LVU195
 593               		.loc 1 301 3 view .LVU196
 594               	.LBE80:
 595 0128 80E0      		ldi r24,lo8(__c.1873)
 596 012a 90E0      		ldi r25,hi8(__c.1873)
 597 012c 0E94 0000 		call print_P
 598               	.LVL46:
 302:iambic.c      **** 		phex(value);
 599               		.loc 1 302 3 view .LVU197
 600 0130 812F      		mov r24,r17
 601 0132 0E94 0000 		call phex
 602               	.LVL47:
 303:iambic.c      **** 
 304:iambic.c      **** 		if (!c)
 603               		.loc 1 304 3 view .LVU198
 604               		.loc 1 304 6 is_stmt 0 view .LVU199
 605 0136 0023      		tst r16
 606 0138 01F4      		brne .+2
 607 013a 00C0      		rjmp .L35
 305:iambic.c      **** 		{
 306:iambic.c      **** 			bad_input();
 307:iambic.c      **** 			goto reset;
 308:iambic.c      **** 		}
 309:iambic.c      **** 
 310:iambic.c      **** 		pchar('\n');
 608               		.loc 1 310 3 is_stmt 1 view .LVU200
 609 013c 8AE0      		ldi r24,lo8(10)
 610 013e 0E94 0000 		call usb_debug_putchar
 611               	.LVL48:
 311:iambic.c      **** 		
 312:iambic.c      **** 		const uint8_t modbit = c & 0x80 ? KEY_SHIFT : 0;
 612               		.loc 1 312 3 view .LVU201
 313:iambic.c      **** 		c &= ~0x80;
 613               		.loc 1 313 3 view .LVU202
 314:iambic.c      **** 		usb_keyboard_press(c, modbit);
 614               		.loc 1 314 3 view .LVU203
 312:iambic.c      **** 		c &= ~0x80;
 615               		.loc 1 312 47 is_stmt 0 view .LVU204
 616 0142 602F      		mov r22,r16
 617 0144 66FB      		bst r22,6
 618 0146 660F      		lsl r22
 619 0148 660B      		sbc r22,r22
 620 014a 60F9      		bld r22,0
 312:iambic.c      **** 		c &= ~0x80;
 621               		.loc 1 312 17 view .LVU205
 622 014c 6270      		andi r22,lo8(2)
 623               	.LVL49:
 624               		.loc 1 314 3 view .LVU206
 625 014e 802F      		mov r24,r16
 626 0150 8F77      		andi r24,lo8(127)
 627               	.LVL50:
 628               		.loc 1 314 3 view .LVU207
 629 0152 0E94 0000 		call usb_keyboard_press
 630               	.LVL51:
 631               		.loc 1 314 3 view .LVU208
 632 0156 00C0      		rjmp .L23
 633               	.LVL52:
 634               	.L21:
 635               	.LBB81:
 289:iambic.c      **** 			if (is_dah(port))
 636               		.loc 1 289 4 is_stmt 1 view .LVU209
 289:iambic.c      **** 			if (is_dah(port))
 637               		.loc 1 289 18 is_stmt 0 view .LVU210
 638 0158 83B1      		in r24,0x3
 639               	.LVL53:
 290:iambic.c      **** 				goto start_dah_bit;
 640               		.loc 1 290 4 is_stmt 1 view .LVU211
 641 015a 8983      		std Y+1,r24
 642               	.LVL54:
 643               	.LBB82:
 644               	.LBI82:
  71:iambic.c      **** 	const uint8_t value
 645               		.loc 1 71 1 view .LVU212
 646               	.LBB83:
  75:iambic.c      **** }
 647               		.loc 1 75 2 view .LVU213
  75:iambic.c      **** }
 648               		.loc 1 75 9 is_stmt 0 view .LVU214
 649 015c 8981      		ldd r24,Y+1
 650               	.LVL55:
  75:iambic.c      **** }
 651               		.loc 1 75 9 view .LVU215
 652               	.LBE83:
 653               	.LBE82:
 290:iambic.c      **** 				goto start_dah_bit;
 654               		.loc 1 290 7 view .LVU216
 655 015e 84FF      		sbrs r24,4
 656 0160 00C0      		rjmp .L17
 292:iambic.c      **** 				goto start_dit_bit;
 657               		.loc 1 292 4 is_stmt 1 view .LVU217
 658               	.LVL56:
 659               	.LBB84:
 660               	.LBI84:
  80:iambic.c      **** 	const uint8_t value
 661               		.loc 1 80 1 view .LVU218
 662               	.LBB85:
  84:iambic.c      **** }
 663               		.loc 1 84 2 view .LVU219
  84:iambic.c      **** }
 664               		.loc 1 84 9 is_stmt 0 view .LVU220
 665 0162 8981      		ldd r24,Y+1
 666               	.LVL57:
  84:iambic.c      **** }
 667               		.loc 1 84 9 view .LVU221
 668               	.LBE85:
 669               	.LBE84:
 292:iambic.c      **** 				goto start_dit_bit;
 670               		.loc 1 292 7 view .LVU222
 671 0164 85FD      		sbrc r24,5
 672 0166 00C0      		rjmp .L20
 673 0168 00C0      		rjmp .L16
 674               	.LBE81:
 675               	.LBE87:
 676               		.cfi_endproc
 677               	.LFE15:
 679               		.section	.progmem.data,"a",@progbits
 682               	__c.1835:
 683 0000 2121 210A 		.string	"!!!\n"
 683      00
 686               	__c.1873:
 687 0005 203D 2000 		.string	" = "
 690               	morse.1850:
 691 0009 00        		.string	""
 692 000a 00        		.string	""
 693 000b 0817 0C04 		.string	"\b\027\f\004\021\020\026\030\025\032\007\016\n\022\013\031\t,\017"
 693      1110 1618 
 693      151A 070E 
 693      0A12 0B19 
 693      092C 0F00 
 694 001f 130D 052E 		.string	"\023\r\005.\006\034\035\024"
 694      061C 1D14 
 694      00
 695 0028 00        		.string	""
 696 0029 2221 00   		.string	"\"!"
 697 002c 2000      		.string	" "
 698 002e 00        		.string	""
 699 002f 00        		.string	""
 700 0030 1FA4 00   		.string	"\037\244"
 701 0033 AE00      		.string	"\256"
 702 0035 00        		.string	""
 703 0036 00        		.string	""
 704 0037 00        		.string	""
 705 0038 1E23 00   		.string	"\036#"
 706 003b 3800      		.string	"8"
 707 003d 00        		.string	""
 708 003e 00        		.string	""
 709 003f A600      		.string	"\246"
 710 0041 2400      		.string	"$"
 711 0043 00        		.string	""
 712 0044 00        		.string	""
 713 0045 2500      		.string	"%"
 714 0047 2627 00   		.string	"&'"
 715 004a 00        		.string	""
 716 004b 00        		.string	""
 717 004c 00        		.string	""
 718 004d 00        		.string	""
 719 004e 00        		.string	""
 720 004f 00        		.string	""
 721 0050 00        		.string	""
 722 0051 00        		.string	""
 723 0052 00        		.string	""
 724 0053 00        		.string	""
 725 0054 00        		.string	""
 726 0055 B8AD 00   		.string	"\270\255"
 727 0058 00        		.string	""
 728 0059 00        		.string	""
 729 005a 00        		.string	""
 730 005b B400      		.string	"\264"
 731 005d 00        		.string	""
 732 005e 3700      		.string	"7"
 733 0060 00        		.string	""
 734 0061 00        		.string	""
 735 0062 00        		.string	""
 736 0063 9F00      		.string	"\237"
 737 0065 00        		.string	""
 738 0066 00        		.string	""
 739 0067 3400      		.string	"4"
 740 0069 00        		.string	""
 741 006a 2D00      		.string	"-"
 742 006c 00        		.string	""
 743 006d 00        		.string	""
 744 006e 00        		.string	""
 745 006f 00        		.string	""
 746 0070 00        		.string	""
 747 0071 00        		.string	""
 748 0072 00        		.string	""
 749 0073 339E 00   		.string	"3\236"
 750 0076 A700      		.string	"\247"
 751 0078 00        		.string	""
 752 0079 00        		.string	""
 753 007a 00        		.string	""
 754 007b 00        		.string	""
 755 007c 3600      		.string	"6"
 756 007e 00        		.string	""
 757 007f 00        		.string	""
 758 0080 00        		.string	""
 759 0081 B300      		.string	"\263"
 760 0083 00        		.string	""
 761 0084 00        		.string	""
 762 0085 00        		.string	""
 763 0086 00        		.string	""
 764 0087 00        		.string	""
 765 0088 00        		.string	""
 766 0089 00        		.string	""
 767 008a 00        		.string	""
 768 008b 00        		.string	""
 769 008c 00        		.string	""
 770 008d 00        		.string	""
 771 008e 00        		.string	""
 772 008f 00        		.string	""
 773 0090 00        		.string	""
 774 0091 00        		.string	""
 775 0092 A100      		.string	"\241"
 776 0094 0000 0000 		.zero	117
 776      0000 0000 
 776      0000 0000 
 776      0000 0000 
 776      0000 0000 
 779               	__c.1863:
 780 0109 2D00      		.string	"-"
 783               	__c.1859:
 784 010b 2E00      		.string	"."
 785               		.local	dit_count
 786               		.comm	dit_count,2,1
 787               		.local	dah_count
 788               		.comm	dah_count,2,1
 789               	.global	idle_count
 790               		.section .bss
 793               	idle_count:
 794 0000 0000      		.zero	2
 795               	.global	number_keys
 796               		.data
 799               	number_keys:
 800 0000 271E 1F20 		.ascii	"'\036\037 !\"#$%&"
 800      2122 2324 
 800      2526 
 801               		.text
 802               	.Letext0:
 803               		.file 4 "/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/stdint.h"
 804               		.file 5 "usb_keyboard_debug.h"
 805               		.file 6 "print.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 iambic.c
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:4      *ABS*:000000000000003f __SREG__
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:12     .text.led_on:0000000000000000 led_on
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:35     .text.led_off:0000000000000000 led_off
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:57     .text.busy_wait:0000000000000000 busy_wait
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:786    .bss:0000000000000004 dah_count
                             .bss:0000000000000002 dit_count
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:169    .text.bad_input:0000000000000000 bad_input
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:682    .progmem.data:0000000000000000 __c.1835
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:244    .text.startup.main:0000000000000000 main
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:783    .progmem.data:000000000000010b __c.1859
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:779    .progmem.data:0000000000000109 __c.1863
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:690    .progmem.data:0000000000000009 morse.1850
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:686    .progmem.data:0000000000000005 __c.1873
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:793    .bss:0000000000000000 idle_count
/var/folders/cf/2ytwk0ds25l23zw7m7955dkm0000gn/T//ccmI83kB.s:799    .data:0000000000000000 number_keys

UNDEFINED SYMBOLS
print_P
usb_init
usb_configured
phex
usb_debug_putchar
usb_keyboard_press
__do_copy_data
__do_clear_bss
